{# Vesper Python Code Generator Template #}
{# This template generates idiomatic, production-ready Python code from Vesper specifications #}
"""
AUTO-GENERATED by Vesper Compiler v0.1.0 - DO NOT EDIT

Node: {{ node.node_id }}
Type: {{ node.type.value }}
Intent: {{ node.intent }}
{% if node.metadata.description %}

Description:
{{ node.metadata.description | indent(4) }}
{% endif %}
{% if node.metadata.version %}
Version: {{ node.metadata.version }}
{% endif %}
Generated: {{ timestamp }}

Source: {{ source_file if source_file else 'inline' }}
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import Any, Union
{% if has_async_operations %}
import asyncio
{% endif %}
{% if has_http_operations %}
import httpx
{% endif %}
{% if has_db_operations %}
# Database client should be injected via dependency injection
{% endif %}

logger = logging.getLogger(__name__)


# ============================================================================
# Result Types
# ============================================================================

@dataclass
class SuccessResult:
    """
    Success result for {{ node.node_id }}.

    Fields:
{% for field_name, field_spec in success_fields.items() %}
        {{ field_name }}: {{ field_spec.type_hint }} - {{ field_spec.description or 'No description' }}
{% endfor %}
    """
{% if success_fields %}
{% for field_name, field_spec in success_fields.items() %}
    {{ field_name }}: {{ field_spec.type_hint }}{{ ' = ' + field_spec.default if field_spec.default else '' }}
{% endfor %}
{% else %}
    pass
{% endif %}


@dataclass
class ErrorResult:
    """
    Error result for {{ node.node_id }}.

    Possible error codes:
{% for code in error_codes %}
        - {{ code }}
{% endfor %}
    """
    error_code: str
    message: str
{% for field_name, field_spec in error_fields.items() %}
{% if field_name not in ['error_code', 'message'] %}
    {{ field_name }}: {{ field_spec.type_hint }}{{ ' = None' if not field_spec.required else '' }}
{% endif %}
{% endfor %}


@dataclass
class ExecutionResult:
    """
    Execution result wrapper.

    Either `success` or `error` will be populated, never both.
    """
    success: SuccessResult | None = None
    error: ErrorResult | None = None

    @property
    def is_success(self) -> bool:
        """Return True if the execution succeeded."""
        return self.success is not None

    @property
    def is_error(self) -> bool:
        """Return True if the execution failed."""
        return self.error is not None

    def unwrap(self) -> SuccessResult:
        """
        Unwrap the success result or raise an exception.

        Raises:
            RuntimeError: If the result is an error
        """
        if self.success is None:
            raise RuntimeError(f"Execution failed: {self.error}")
        return self.success


# ============================================================================
# Contracts
# ============================================================================

class ContractViolation(Exception):
    """Raised when a precondition or postcondition is violated."""

    def __init__(self, contract_type: str, condition: str, message: str = ""):
        self.contract_type = contract_type
        self.condition = condition
        super().__init__(f"{contract_type} violated: {condition}. {message}")


def _check_preconditions({% for name in input_names %}{{ name }}: {{ input_types[name] }}{{ ', ' if not loop.last else '' }}{% endfor %}) -> None:
    """
    Verify preconditions before execution.

    Preconditions:
{% for precond in preconditions %}
        - {{ precond.original }}
{% endfor %}
    """
{% if not preconditions %}
    pass  # No preconditions defined
{% else %}
{% for precond in preconditions %}
    if not ({{ precond.python }}):
        raise ContractViolation(
            "Precondition",
            "{{ precond.original | replace('"', '\\"') }}",
            "Condition evaluated to False"
        )
{% endfor %}
{% endif %}


def _check_postconditions(
    result: ExecutionResult,
    {% for name in input_names %}{{ name }}: {{ input_types[name] }}{{ ', ' if not loop.last else '' }}{% endfor %}
) -> None:
    """
    Verify postconditions after execution.

    Postconditions:
{% for postcond in postconditions %}
        - {{ postcond.original }}
{% endfor %}
    """
{% if not postconditions %}
    pass  # No postconditions defined
{% else %}
    # Extract result values for postcondition checks
    if result.success:
{% for field_name in success_fields.keys() %}
        {{ field_name }} = result.success.{{ field_name }}
{% endfor %}
    if result.error:
        error_code = result.error.error_code
        message = result.error.message
{% for postcond in postconditions %}
    # Note: Postcondition "{{ postcond.original }}" may require runtime context
{% endfor %}
{% endif %}


# ============================================================================
# Flow Step Implementations
# ============================================================================

{% for step in flow_steps %}
def _step_{{ step.name }}(
    context: dict[str, Any]
) -> dict[str, Any]:
    """
    {{ step.description or 'Execute step: ' + step.name }}

    Operation: {{ step.operation }}
    """
{% if step.code_lines %}
{% for line in step.code_lines %}
    {{ line }}
{% endfor %}
{% else %}
    # TODO: Implement {{ step.operation }} operation
    pass
{% endif %}
    return context

{% endfor %}

# ============================================================================
# Main Function
# ============================================================================

def {{ function_name }}(
{% for name, type_hint in input_signature.items() %}
    {{ name }}: {{ type_hint }}{{ ',' if not loop.last else '' }}
{% endfor %}
) -> ExecutionResult:
    """
    {{ node.intent | capitalize }}

    This function was generated from a Vesper specification.
    Node ID: {{ node.node_id }}

    Args:
{% for name, spec in input_specs.items() %}
        {{ name }}: {{ spec.description or spec.type }}
{% if spec.constraints %}
            Constraints: {{ spec.constraints | join(', ') }}
{% endif %}
{% endfor %}

    Returns:
        ExecutionResult containing either SuccessResult or ErrorResult

    Raises:
        ContractViolation: If preconditions or postconditions are violated
{% if node.performance.timeout_seconds %}

    Performance:
        Expected latency: {{ node.performance.expected_latency_ms or 'N/A' }}ms
        Timeout: {{ node.performance.timeout_seconds }}s
{% endif %}
    """
    logger.debug(
        "Executing {{ function_name }}",
        extra={
            "node_id": "{{ node.node_id }}",
{% for name in input_names[:3] %}
            "{{ name }}": {{ name }},
{% endfor %}
        }
    )

    try:
        # ================================================================
        # Precondition Verification
        # ================================================================
        _check_preconditions({% for name in input_names %}{{ name }}={{ name }}{{ ', ' if not loop.last else '' }}{% endfor %})

        # ================================================================
        # Flow Execution
        # ================================================================

        # Initialize execution context with inputs
        context: dict[str, Any] = {
{% for name in input_names %}
            "{{ name }}": {{ name }},
{% endfor %}
        }

{% for step in flow_steps %}
        # Step {{ loop.index }}: {{ step.name }} ({{ step.operation }})
{% if step.guard %}
        if {{ step.guard }}:
            context = _step_{{ step.name }}(context)
{% else %}
        context = _step_{{ step.name }}(context)
{% endif %}

{% endfor %}
        # ================================================================
        # Build Success Result
        # ================================================================
        result = ExecutionResult(
            success=SuccessResult(
{% for field_name in success_fields.keys() %}
                {{ field_name }}=context.get("{{ field_name }}"),
{% endfor %}
            )
        )

        # ================================================================
        # Postcondition Verification
        # ================================================================
        _check_postconditions(result, {% for name in input_names %}{{ name }}={{ name }}{{ ', ' if not loop.last else '' }}{% endfor %})

        logger.info(
            "{{ function_name }} completed successfully",
            extra={"node_id": "{{ node.node_id }}"}
        )

        return result

    except ContractViolation:
        # Re-raise contract violations - these are programming errors
        raise

    except Exception as e:
        logger.error(
            "{{ function_name }} failed",
            extra={
                "node_id": "{{ node.node_id }}",
                "error": str(e),
                "error_type": type(e).__name__,
            },
            exc_info=True
        )

        return ExecutionResult(
            error=ErrorResult(
                error_code=type(e).__name__,
                message=str(e)
            )
        )


# ============================================================================
# Verified Wrapper (with full contract checking)
# ============================================================================

def {{ function_name }}_verified(
{% for name, type_hint in input_signature.items() %}
    {{ name }}: {{ type_hint }}{{ ',' if not loop.last else '' }}
{% endfor %}
) -> ExecutionResult:
    """
    Verified wrapper for {{ function_name }}.

    This wrapper explicitly checks all preconditions and postconditions,
    providing detailed error messages when contracts are violated.
    Use this in development/testing for maximum safety.
    """
    return {{ function_name }}({% for name in input_names %}{{ name }}={{ name }}{{ ', ' if not loop.last else '' }}{% endfor %})


# ============================================================================
# CLI Entry Point (for testing)
# ============================================================================

if __name__ == "__main__":
    import json
    import sys

    print("{{ node.node_id }} - {{ node.intent }}")
    print("=" * 60)

    # Example usage with defaults
    example_inputs = {
{% for name, spec in input_specs.items() %}
{% if spec.default is not none %}
        "{{ name }}": {{ spec.default | tojson }},
{% elif spec.type == 'string' %}
        "{{ name }}": "example",
{% elif spec.type == 'integer' %}
        "{{ name }}": 1,
{% elif spec.type == 'decimal' %}
        "{{ name }}": Decimal("1.00"),
{% elif spec.type == 'boolean' %}
        "{{ name }}": True,
{% else %}
        "{{ name }}": None,  # TODO: Provide example value
{% endif %}
{% endfor %}
    }

    print(f"Example inputs: {json.dumps({k: str(v) for k, v in example_inputs.items()}, indent=2)}")

    try:
        result = {{ function_name }}(**example_inputs)
        if result.is_success:
            print(f"Success: {result.success}")
        else:
            print(f"Error: {result.error}")
    except ContractViolation as e:
        print(f"Contract violation: {e}")
    except Exception as e:
        print(f"Exception: {e}")

