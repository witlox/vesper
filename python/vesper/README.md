# Vesper Python Compiler

The Vesper Python compiler transforms Vesper specification files (`.vsp`) into idiomatic, production-ready Python code.

## Overview

The compiler consists of three main components:

1. **Parser** (`compiler.py`) - Parses YAML `.vsp` files into a `VesperNode` AST
2. **Validator** (`validator.py`) - Validates nodes for correctness and best practices
3. **Generator** (`generator.py`) - Generates Python code using Jinja2 templates

## Installation

```bash
# From the project root
pip install -e .
```

## Usage

### Command Line

```bash
# Compile a .vsp file to Python
vesper compile examples/payment_handler/payment_handler.vsp

# Validate only (no code generation)
vesper compile examples/hello_world/hello_world.vsp --validate-only

# Specify output file
vesper compile examples/hello_world/hello_world.vsp -o output/hello.py
```

### Programmatic Usage

```python
from vesper import VesperCompiler, VesperGenerator, VesperValidator

# Method 1: Using the original compiler
compiler = VesperCompiler()
node = compiler.parse("path/to/spec.vsp")
validation = compiler.validate(node)
if validation.valid:
    code = compiler.compile(node)

# Method 2: Using the new template-based generator
generator = VesperGenerator()
validator = VesperValidator()

node = compiler.parse("path/to/spec.vsp")
result = validator.validate(node)
if result.valid:
    code = generator.generate(node)
```

## Generated Code Quality

The generator produces Python code that:

- ✅ Has comprehensive type hints
- ✅ Includes detailed docstrings
- ✅ Implements contract verification (preconditions/postconditions)
- ✅ Has proper error handling with clear error types
- ✅ Includes logging for debugging
- ✅ Is formatted according to PEP 8
- ✅ Can be directly executed or imported

### Example Output

From a simple greeting specification:

```yaml
node_id: greet_user_v1
type: function
intent: Generate a personalized greeting

inputs:
  name:
    type: string
    required: true
    description: The user's name

outputs:
  success:
    message:
      type: string

contracts:
  preconditions:
    - "name != ''"

flow:
  - step: generate_greeting
    operation: string_template
    template: "Hello, {name}!"
    output: message
```

The generator produces:

```python
"""
AUTO-GENERATED by Vesper Compiler v0.1.0 - DO NOT EDIT
Node: greet_user_v1
Intent: Generate a personalized greeting
"""

from __future__ import annotations
import logging
from dataclasses import dataclass
from typing import Any

logger = logging.getLogger(__name__)

@dataclass
class SuccessResult:
    message: str

@dataclass
class ErrorResult:
    error_code: str
    message: str

@dataclass
class ExecutionResult:
    success: SuccessResult | None = None
    error: ErrorResult | None = None
    
    @property
    def is_success(self) -> bool:
        return self.success is not None

class ContractViolation(Exception):
    """Raised when a precondition or postcondition is violated."""
    pass

def greet_user_v1(name: str) -> ExecutionResult:
    """
    Generate a personalized greeting
    
    Args:
        name: The user's name
    
    Returns:
        ExecutionResult with the greeting message
    """
    # Precondition checks
    if not (name != ""):
        raise ContractViolation("Precondition", "name != ''")
    
    try:
        context = {"name": name}
        
        # Step 1: generate_greeting
        context["message"] = f'Hello, {context["name"]}!'
        
        return ExecutionResult(
            success=SuccessResult(message=context.get("message"))
        )
    except Exception as e:
        logger.error(f"greet_user_v1 failed: {e}")
        return ExecutionResult(
            error=ErrorResult(error_code=type(e).__name__, message=str(e))
        )
```

## Validation

The validator checks for:

### Errors (block code generation)
- Missing required fields (node_id, type, intent)
- Invalid node_id format (must be `name_vN`)
- Duplicate step names
- Missing required operation parameters
- Conflicting security capabilities

### Warnings (logged but allow generation)
- Unknown types
- Unknown operations
- Empty flow
- Unbalanced parentheses in conditions
- Dangerous security capabilities

### Info (best practice suggestions)
- Missing description
- Missing test cases
- Short intent

## Templates

The generator uses Jinja2 templates located in `vesper/templates/`:

- `function.py.jinja2` - Main template for Python function generation

You can customize code generation by providing your own template directory:

```python
from pathlib import Path
from vesper import VesperGenerator

generator = VesperGenerator(template_dir=Path("my/templates"))
```

## Testing

```bash
# Run all tests
pytest python/tests/ -v

# Run only generator tests
pytest python/tests/test_generator.py -v

# Run only validator tests
pytest python/tests/test_validator.py -v

# Run with coverage
pytest python/tests/ --cov=vesper --cov-report=html
```

## Type Checking

```bash
mypy python/vesper/
```

## Architecture

```
vesper/
├── __init__.py          # Package exports
├── compiler.py          # Original compiler (string-based)
├── generator.py         # New Jinja2-based generator
├── validator.py         # Comprehensive validator
├── models.py            # Pydantic models for .vsp parsing
├── runtime.py           # Execution runtime
└── templates/
    └── function.py.jinja2  # Code generation template
```

## Critical Assessment

### When Vesper adds value:
- Complex flows with many steps and dependencies
- Systems requiring formal contract verification
- Teams with varying programming skill levels
- Code that needs to be audited or certified

### When to use Python directly:
- Simple functions with straightforward logic
- Performance-critical code requiring optimization
- Exploratory/prototype code
- Teams already proficient in Python

### Honest trade-offs:
- **Pros**: Declarative, contracts are explicit, easier to verify
- **Cons**: Additional abstraction layer, learning curve, debugging complexity

